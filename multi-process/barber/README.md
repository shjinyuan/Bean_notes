进程同步 之 理发师问题
https://blog.csdn.net/duanzhengbing/article/details/52141699

## 问题描述

假设有一个理发店只有一个理发师，一张理发时坐的椅子，若干张普通椅子顾客供等候时坐。没有顾客时，理发师就坐在理发的椅子上睡觉。顾客一到，他不是叫醒理发师，就是离开。如果理发师没有睡觉，而在为别人理发，他就会坐下来等候。如果所有的椅子都坐满了人，最后来的顾客就会离开。
在出现竞争的情况下问题就来了，这和其它的排队问题是一样的。实际上，与哲学家就餐问题是一样的。如果没有适当的解决方案，就会导致进程之间的“饿肚子”和“死锁”。
如理发师在等一位顾客，顾客在等理发师，进而造成死锁。另外，有的顾客可能也不愿按顺序等候，会让一些在等待的顾客永远都不能理发。

## 解决方案

最常见的解决方案就是使用三个信号量（Semaphore）：一个给顾客信号量，一个理发师信号量（看他自己是不是闲着），第三个是互斥信号量（Mutual exclusion，缩写成mutex）。一位顾客来了，他想拿到互斥信号量，他就等着直到拿到为止。顾客拿到互斥信号量后，会去查看是否有空着的椅子（可能是等候的椅子，也可能是理发时坐的那张椅子）。
如果没有一张是空着的，他就走了。如果他找到了一张椅子，就会让空椅子的数量减少一张，这位顾客接下来就使用自己的信号量叫醒理发师。这样，互斥信号标就释放出来供其他顾客或理发师使用。如果理发师在忙，这位顾客就会等。理发师就会进入了一个永久的等候循环，等着被在等候的顾客唤醒。一旦他醒过来，他会给所有在等候的顾客发信号，让他们依次理发。
